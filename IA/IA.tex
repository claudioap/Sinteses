\documentclass[]{report}
\usepackage[a4paper, total={7in, 8.5in}]{geometry}
\usepackage[portuguese]{babel}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{color}
\usepackage{tikz}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{multicol}

\begin{document}
\begin{titlepage}
	\centering
	\vspace{5cm}
	{\huge\bfseries Inteligência Artificial\par}
	\vspace{1cm}
	{\scshape\Large Síntese baseada no conteúdo lecionado na\\
	 FCT/Universidade Nova de Lisboa\par}
	\vspace{2cm}
	Adaptado por:\\
	{\Large \textit{Cláudio Afonso de Sousa Pereira}\\
	(sinteses$\text{@}$claudiop$.$com)\par}
	\vspace{1cm}
	Do material lecionado por:\\
	{\Large \textit{João Alexandre Carvalho Pinheiro Leite}\\
	(jleite$\text{@}$fct$.$unl$.$pt)\par}
	\vspace{1cm}
	E do livro:\\
	{\Large \textit{Artificial Intelligence: A Modern Approach}\\
	(http://aima.eecs.berkeley.edu/)\par}
	\vspace{1cm}
	{\large \today\par}
	\vfill
	Adaptação licenciada:\\
	\href{http://creativecommons.org/licenses/by-sa/4.0/}{\includegraphics[scale=0.8]{../ccbysa.png}}
\end{titlepage}
\setcounter{tocdepth}{1}
\tableofcontents
\chapter{Definição}
\section{O que é}
A definição genérica e formal de IA segundo a \textit{Association for the Advancement of Artificial Intelligence} é:
\begin{quote}
A compreensão científica dos mecanismos subjacentes ao pensamento e ao comportamento inteligente e sua incorporação nas máquinas.
\end{quote}
Pode no entanto ser interpretada de diversas formas distintas:
\begin{table}[htbp]
	\begin{center}
\begin{tabular}{l | l}
Sistemas que pensam como humanos & Sistemas que agem como humanos \\ \hline
Sistemas que pensam racionalmente & Sistemas que agem racionalmente
\end{tabular}
\end{center}
\end{table}
\subsection{Sistemas que pensam como humanos}
Fazer um sistema que pense como humanos requer uma teoria que descreva a mente humana para validar o comportamento do sistema de inteligência artificial.\\
Tal teoria pode ser obtida por:
\begin{itemize}
\item \textbf{Introspeção} - captação de pensamentos
\item \textbf{Experiências Psicológicas} - observação de ações
\item \textbf{Imagens cerebrais} - observação do cérebro
\end{itemize}
Perante uma teoria suficientemente detalhada, é possível implementar a mesma num computador.\\
As áreas que tentam desenvolver teorias da mente são:
\begin{itemize}
\item \textbf{Ciência cognitiva} - técnicas psicológicas
\item \textbf{Neurociência Cognitiva} - técnicas neurológicas
\end{itemize}
A desvantagem deste método de conceção de inteligência artificial é que a obtenção de dados e posterior validação é efetuada por via de experimentação em humanos, e após décadas de investigação ainda não foi possível formular a inteligência humana.\\
Por estes motivos esta área de estudo é considerada distinta da inteligência artificial, apesar de ter muito em comum.
\subsection{Sistemas que pensam racionalmente}
Um sistema que pensa racionalmente é um que tem fundamentos em lógica.\\
A lógica pode ser vista neste contexto como uma interseção de Matemática e Filosofia, e seria possível criarem-se sistemas de raciocínio por base nestas vertentes, no entanto:
\begin{itemize}
\item Nem todos os comportamentos inteligentes são lógicos.
\item Não é simples deliberar o objetivo do pensamento ou quais os pensamentos a ter com lógica.
\item É de elevada complexidade descrever lógica.
\end{itemize}
\subsection{Sistemas que agem racionalmente}
Sistemas que agem racionalmente são construidos por base em \textbf{agentes racionais}.\\
Um \textbf{agente} é entidade uma definida por:
\begin{multicols}{2}
\begin{itemize}
\item Agir autonomamente
\item Percecionar o ambiente
\item Persistir no tempo
\item Adaptar-se a mudanças
\item Criar e perseguir objetivos
\end{itemize}
\end{multicols}
Um agente é racional quando age para obter o melhor resultado, ou, perante incerteza, o melhor resultado esperado.\\
É mais adequado para desenvolvimento cientifico do que as abordagens baseadas no comportamento humano.
\section{Fundações}
A inteligência artificial exige avanços em muitas áreas de estudo, sendo que a execução responde questões das mesmas.
\begin{multicols}{2}
\subsection{Filosofia}
Respondendo ás questões:
\begin{itemize}
\item Pode-se inferir conclusões válidas por regras formais?
\item Como é que a mente emerge de um cérebro físico?
\item De onde vem o conhecimento?
\item Como é que o conhecimento leva à ação?
\end{itemize}
Contribui-se para o estudo de:
\begin{itemize}
\item Lógica
\item Métodos de raciocínio
\item Compreensão da mente como um sistema físico
\item Fundamentos da aprendizagem
\item Linguagem
\item Racionalidade
\end{itemize}
\subsection{Matemática}
Respondendo ás questões:
\begin{itemize}
\item Que regras formais inferem conclusões válidas?
\item O que pode ser computado?
\item Como raciocinar com informação incerta?
\end{itemize}
Contribui-se para o estudo de:
\begin{itemize}
\item Representação formal e prova
\item Algoritmos
\item Computação
\item Determinação da decibibilidade
\item Determinação da tractibilidade %TODO (o que é?)
\item Probabilidades
\end{itemize}
\subsection{Economia}
Respondendo ás questões:
\begin{itemize}
	\item O que decidir para maximizar o ganho?
	\item Como lidar com a falta de cooperação?
	\item Como agir perante ganhos distantes no futuro?
\end{itemize}
Contribui-se para o estudo de:
\begin{itemize}
	\item Teoria formal de decisões formais.
	\item Teoria da utilidade.
	\item Teoria de jogos.
\end{itemize}
\subsection{Neurociência}
Respondendo à questão:\\
\indent Como é que os cérebros processam informação?\\
Contribui-se para o estudo da atividade mental.
\subsection{Psicologia}
Respondendo à questão:\\
\indent Como é que os animais pensam e agem?\\
Contribui-se para o estudo de:
\begin{itemize}
    \item Cognição
    \item Comportamento
    \item Adaptação
    \item Perceção e controlo motor
\end{itemize}
\subsection{Informática}
Respondendo à questão:\\
\indent Como construir um computador eficiente?\\
Contribui-se para o estudo de:
\begin{itemize}
\item Conceção de hardware.
\item Fundamentos dos sistemas operativos.
\item Otimização de programas e linguagens de programação.
\end{itemize}
\subsection{Teoria de controlo e cibernética}
Respondendo à questão:\\
\indent Como é que artefactos se podem controlar?\\
Contribui-se para o estudo de:
\begin{itemize}
	\item Sistemas homoestáticos.
	\item Estabilidade.
	\item Desenhos ótimos para agentes simples.
\end{itemize}
\subsection{Linguística}
Respondendo à questão:\\
\indent Qual a relação da linguagem com o pensamento?\\
Contribui-se para o estudo de:
\begin{itemize}
\item Representação de conhecimento.
\item Gramática.
\end{itemize}
\end{multicols}
\section{Contributos importantes}
\begin{itemize}
	\item Teorema de incompletude de Gödel (1931)\\
	As questões matemáticas não são todas computáveis.
	\item Problema da paragem de Turing (1936)\\
	Não é possível criar um programa que determina se outro programa tem fim.
	\item Teorema por Warren McCulloch e Walter Pitts (1943)\\
	Uma máquina de Turing pode ser implementada numa rede finita de neurónios.
\end{itemize}
\chapter{Agentes}
\section{Caraterísticas dos agentes}
Agentes são sistemas num \textbf{ambiente}, a partir qual retiram informação com \textbf{sensores} e agem com \textbf{atuadores}.\\
Tem:
\begin{multicols}{2}
\begin{itemize}
\item Um corpo físico
\item Uma localização (No tempo e espaço)
\item Capacidades (Sensores e atuadores)
\item Capacidade de decisão (Deliberativa ou não)
\end{itemize}
\end{multicols}
Existem diversos tipos de agentes conhecidos:
\begin{itemize}
\item Biológicos\\
Os \textbf{sensores} são olhos, ouvidos, pele, ...\\
Os \textbf{atuadores} são as mãos, pernas, boca, ...
\item Robóticos\\
Os \textbf{sensores} são câmaras, sensores de proximidade, ...\\
Os \textbf{atuadores} são motores,...
\item Computacionais\\
Os \textbf{sensores} são um teclado, rato, ligações de rede, ...\\
Os \textbf{atuadores} são o ecrã, uma placa de controlo, um email enviado, ...
\end{itemize}
\section{Definição sistemática}
Um \textbf{ambiente} carateriza-se por conjuntos de \textbf{estados} $E$.\\
Os estados sofrem transições não deterministas:
$$[ \text{Ambiente: } E \times A \to 2^E]$$ %TODO Explicar o que é isto
O agente é constituído por duas funções:
$$[\text{Percepção: }: E \to P] \hspace{3cm} [\text{Ação }: P^{\star} \to A]$$
e implementa: $[\text{Agente }: E^\star \to A]$
\section{Agentes racionais}
Um agente tem uma \textbf{medida de desempenho}. Um agente racional é um agente que maximiza o valor esperado da medida de desempenho, tentando sempre fazer o que lhe é mais benéfico.\\[2mm]
Racionalidade não implica:
\begin{multicols}{3}
\begin{itemize}
\item \textbf{Omnisciência} (Tudo saber)
\item \textbf{Derividência} (Tudo prever)
\item \textbf{Sucesso}
\end{itemize}
\end{multicols}
\noindent No entanto pressupõe:
\begin{multicols}{2}
\begin{itemize}
\item \textbf{Obtenção de informação}
\item \textbf{Exploração}
\item \textbf{Aprendizagem}
\item \textbf{Autonomia}
\end{itemize}
\end{multicols}
\section{Performance measure environment, actuators, sensors (PEAS)}
O \textbf{PEAS} é uma especificação do ambiente de execução de um agente, com os seguintes atributos:
\begin{itemize}
	\item Medida desempenho\\
	Um critério para avaliar o agente. Pode ser composto de sub-critérios.\\
	Ex: Eficácia, satisfação, eficiência, etc ...
	\item Ambiente\\
	Ambiente em que o agente se encontra inserido.\\
	Ex: Maquina com dimensões $x, y, z$, na estrada, a interagir com peões.
	\item Atuadores\\
	Ex: Ecrã, braço robótico, coluna, etc ...
	\item Sensores\\
	Ex: Câmara, placa de pressão, botões, etc ...
\end{itemize}
\clearpage
\section{Propriedades dos ambientes}
\begin{multicols}{2}
\subsection{Observabilidade}
Um ambiente é \textbf{totalmente observável} se o agente for omnisciente, isto é, souber o estado atual de tudo.\\
Por outro lado é \textbf{parcialmente observável} se o agente só conseguir obter alguma informação em cada instante.
\subsection{Determinístico ou estocástico}
Um ambiente é \textbf{determinista} se as ações do agente sobre o ambiente forem deterministas.
Se as ações do próprio agente forem determinísticas, mas não as de terceiros, então o ambiente é \textbf{estratégico}.
Caso o ambiente não seja determinístico é \textbf{estocástico}.
\subsection{Episódico ou sequencial}
Um ambiente é \textbf{episódico} se as experiências são atómicas e cada perceção é seguida de uma única ação, sem dependência das anteriores.\\
O oposto é um ambiente \textbf{sequencial}.
\subsection{Estático ou dinâmico}
Um ambiente é \textbf{estático} se não altera durante a deliberação do agente.
Pelo contrário é \textbf{dinâmico} caso se altere.\\
É ainda \textbf{semi-dinâmico} caso seja estático mas a medida de desempenho se alterar com o tempo.
\subsection{Discreto ou continuo}
Se o ambiente tiver um numero finito de ações e perceções forem e todas bem definidas, o ambiente é \textbf{discreto}.\\
Caso contrario, caso as ações ou perceções é \textbf{continuo}.
\subsection{Agente único ou multi-agente}
Se o agente for o único no ambiente, o ambiente tem \textbf{agente único}.\\
Caso contrario é um ambiente \textbf{multi-agente}.
\end{multicols}
\section{Propriedades dos agentes}
Um agente pode verificar uma combinação das seguintes propriedades:
\begin{multicols}{2}
\subsection{Racional}
Maximiza o desempenho em função dos dados obtidos
\subsection{Reativo}
Responde em tempo útil a mudanças no ambiente.
\subsection{Proativo}
Tem iniciativa em vez de apenas reagir.
\subsection{Comunicação}
Comunica com os outros agentes.
\subsection{Autónomo}
Aprende e adapta-se com experiências anteriores
\subsection{Móvel}
Consegue deslocar-se
\subsection{Caráter}
Têm estado emocional e uma propriedade própria.
\end{multicols}
\clearpage
\section{Arquiteturas de agentes}
Os agentes tem uma arquitetura associada ao seu funcionamento que dita como é que operam.
\subsection{Agente reativo puro}
Um \textbf{agente reativo puro} perceciona o mundo pelos seus sensores e recorre a um conjunto de regras suas para decidir o que fazer. Como o nome indica, para cada ação deverá de ter uma reação.
\begin{algorithm}
	\caption{Conceito de um agente reativo simples}
	\begin{algorithmic}
		\Function{AGENTE-REATIVO-SIMPLES}{\textit{perceção}} \textbf{returns} \textit{ação}
		\State \textbf{persistent:} \textit{regras}, um conjunto de regras ação-condição
		\State \textit{estado} $\gets$ INTERPRETAR(\textit{perceção})
		\State \textit{regra} $\gets$ OPTAR(\textit{estado, regras})
		\State \textit{ação} $\gets$ EXECUTAR(\textit{regra})
		\State \Return ação
		\EndFunction
	\end{algorithmic}
\end{algorithm}
\paragraph{Programas Teleo-Reativos (Nilsson)}
São programas definidos por um uma sequência de regras.
$$\{\{c_1 \rightarrow a_1\}, \{c_2 \rightarrow a_2\}, \dots, \{c_n \rightarrow a_n\}\}$$
Cada $c_k$ é uma condição dada por uma conjunção de preposições booleanas e cada $a_k$ é uma ação a executar.\\
Opta-se sempre por executar a primeira condição que se verifique verdadeira.\\[2mm]
Um agente reativo puro é baseado num programa Teleo-Reativo.
\subsection{Agente reativo com estado}
O \textbf{agente reativo com estado} (ou \textbf{agente baseado em modelos}) é uma modificação do agente reativo puro que o permite memorizar as mudanças no mundo.
\begin{algorithm}
	\caption{Conceito de um agente reativo com estado}
	\begin{algorithmic}
		\Function{AGENTE-REATIVO-COM-ESTADO}{\textit{perceção}} \textbf{returns} \textit{ação}
		\State \textbf{persistent:} \textit{estado}, descrição do estado atual do mundo
		\State \hspace{12mm} \textit{regras}, um conjunto de regras ação-condição
		\State \hspace{12mm} \textit{ação}, ultima ação
		\State \textit{estado} $\gets$ ATUALIZA-ESTADO(\textit{estado, ação, perceção})
		\State \textit{regra} $\gets$ OPTAR(\textit{estado, regras})
		\State \textit{ação} $\gets$ EXECUTAR(\textit{regra})
		\State \Return ação
		\EndFunction
	\end{algorithmic}
\end{algorithm}
\subsection{Agente guiado por objetivo}
Um agente que considera o impacto das ações no mundo, tanto para as ações passadas (avalia o resultado que tiveram), como para ações futuras (tenta prever as eventuais consequências).
A partir das considerações, calcula o que pensa serem as melhores ações para chegar ao objetivo.
\subsection{Agente guiado com função de utilidade}
Um agente similar ao guiado por objetivo, mas considera a utilidade em vez dos objetivos, isto é, durante o seu tempo de execução, tenta maximizar a sua utilidade em todos os instantes de tempo, mesmo que isso não o leve a nenhum ``objetivo".
\subsection{Agente aprendiz}
Um \textbf{agente aprendiz} é composto pelos componentes:
\begin{itemize}
	\item \textbf{Critico}, métricas de sucesso.
	\item \textbf{Elemento de aprendizagem}, responsável por fazer melhorias por base no critico.
	\item \textbf{Elemento de performance}, responsável por selecionar ações por base no elemento de aprendizagem.
	\item \textbf{Gerador de problemas}, sugere ao elemento de performance ações que levam a aprendizagem de informação.
\end{itemize}
\section{Representações internas dos agentes}
\subsection{Atómica}
Representação sem uma estrutura interna, semelhante a uma caixa negra.
\subsection{Fatorizada}
Representação com um numero finito de atributos atómicos.\\
Exemplo: Problemas de satisfação de restrições, lógica proposicional, etc..
\subsection{Estruturada}
Representação com relações entre objetos.\\
Exemplo: Bases de dados relacionais, lógica de primeira ordem, modelos probabilísticos, etc..
\chapter{Procura}
Um \textbf{problema de procura} é um problema cuja solução é uma sequência de ações que levam de um estado inicial ao estado final. Um problema de procura é \textbf{procura cega} se o agente só conseguir gerar estados sucessores e verificar se são o estado final.
\section{Formulação de um agente de procura}
Para se formular um agente que resolva problemas de procura tem de se assumir que o ambiente é estático (não muda durante a resolução), observável (sabe o estado corrente).\\[2mm]
É necessário formular o problema e o objetivo.
\begin{itemize}
	\item \textbf{Estado inicial}, estado associado á sequência vazia de ações.
	\item \textbf{Teste objetivo}, critério que dita se o objetivo foi alcançado.
	\item \textbf{Função sucessor}, uma função que gera sucessores a partir do estado atual
	\item \textbf{Modelo de transição}, as transições para outros estados aquando das ações.
	\item \textbf{Custo}, uma métrica que avalia a sequência de ações.
\end{itemize}
Para um agente que procure encontrar o caminho entre duas cidades:
\begin{itemize}
	\item O estado inicial é a cidade de origem.
	\item O teste objetivo indica se a cidade atual é a cidade de destino.
	\item A função sucessor indica as cidades sucessoras à cidade atual
	\item O modelo de transição indica os meios a tomar para chegar ás cidades sucessoras.
	\item O custo é a soma de uma propriedade dos meios utilizados (kilometros, euros, ...)
\end{itemize}
\clearpage
\section{Árvores de Procura}
As \textbf{árvores de procura} são um método de estruturar um problema de procura.
\begin{itemize}
	\item A raiz é o estado inicial.
	\item Cada nó é um estado.
	\item Filhos de um nó são os seus sucessores.
	\item Arestas são modelos de transição.
	\item Folhas são sucessores por explorar (fronteira) ou nós sem sucessor.
\end{itemize}
\begin{algorithm}
	\caption{Algoritmo genérico de uma árvore de procura}
	\begin{algorithmic}
		\Function{ÁRVORE-PROCURA}{\textit{problema, fronteira}} \textbf{returns} \textit{solução, fracasso}
		\State \textit{nó} $\gets$ \textit{problema.ESTADO-INICIAL}
		\State \textit{fronteira} $\gets$ INSERIR(\textit{nó, fronteira})
		\Loop
		\If {VAZIA?(\textit{fronteira})}
		\Return \textit{fracasso}
		\EndIf
		\State \textit{nó} $\gets$ SUCESSOR(\textit{fronteira})
		\If {\textit{problema.TESTE-OBJETIVO}(\textit{nó})}
		\Return SOLUÇÃO(nó)
		\EndIf
		\State \textit{fronteira} $\gets$ INSERIR(EXPANDIR(\textit{nó}), \textit{fronteira})
		\EndLoop
		\EndFunction
		% TODO função EXPANDIR
	\end{algorithmic}
\end{algorithm}
À árvore que estrutura um dado problema podem aplicados diversos algoritmos que tem diversas propriedades:
\begin{itemize}
	\item \textbf{Completude}: O algoritmo vai garantidamente chegar a soluções (caso existam).
	\item \textbf{Ótimalidade}: A solução encontrada será a de menor custo.
	\item \textbf{Complexidade temporal}: Proporção entre o tamanho do problema e o tempo necessário para resolver.
	\item \textbf{Complexidade espacial}: Proporção entre o tamanho do problema e o espaço necessário para resolver.
\end{itemize}
No exemplo das cidades:
\begin{quotation}
\noindent Um algoritmo que possa ficar preso num conjunto de cidades não é completo.\\
Um algoritmo que escolha percursos sem considerar custos não é ótimo.\\
Algoritmos que não considerem (por exemplo) estados repetidos tem uma elevada complexidade temporal.\\
Algoritmos que mantenham uma grande fronteira tem uma elevada complexidade espacial.
\end{quotation}
\section{Grafos de Procura}
Os grafos de procura são similares ás árvores de procura, sendo intercambiáveis com as mesmas.\\
Uma vez que um grafo não degenerado tem ciclos é preciso especial cuidado para garantir que um algoritmo de procura em grafos é completo.
\clearpage
\section{Algoritmos de Procura Cega}
Seja $b$ o branching factor (numero máximo de sucessores de um nó), $d$ a profundidade da árvore.
\subsection{Procura em Largura}
Abreviado \textbf{BFS} (Breadth First Search)\\
A fronteira é uma fila FIFO.\\
Os sucessores de um nó expandido são colocados no fim da fila.\\
Este algoritmo:
\begin{itemize}
	\item É completo para $b$ finito.
	\item É ótimo se todas as ações tiverem o mesmo custo.
	\item Tem uma complexidade temporal $O(b^{d+1})$.
	\item Tem uma complexidade espacial $O(b^{d+1})$.
\end{itemize}
O espaço ocupado torna este algoritmo inviável para caminhos longos com branching elevados.
\subsection{Procura de Custo Uniforme}
A fronteira é uma fila ordenada pelo custo acumulado.\\
Os sucessores de um nó expandido são colocados no fim da fila.\\
Este algoritmo:
\begin{itemize}
	\item É completo se custos monótonos crescentes.
	\item É ótimo.
	\item Tem uma complexidade temporal $O(b^{1+ \lceil C^\star / \mathcal{E} \rceil})$ (com $C^\star$ o custo ótimo).
	\item Tem uma complexidade espacial $O(b^{1+ \lceil C^\star / \mathcal{E} \rceil})$.
\end{itemize}
\subsection{Procura em Profundidade}
Abreviado \textbf{DFS} (Depth First Search)\\
A fronteira é uma fila LIFO.\\
Os sucessores de um nó expandido são os primeiros a testar e expandir se necessário.\\
Sendo $m$ a profundidade máxima, este algoritmo:
\begin{itemize}
	\item Não é completo em espaços de profundidade infinita ou com ciclos.
	\item Não é ótimo.
	\item Tem uma complexidade temporal $O(b^m)$.
	\item Tem uma complexidade espacial $O(bm)$.
\end{itemize}
\subsection{Procura de Profundidade Limitada}
Sendo $l$ o limite de profundidade imposto, este algoritmo:
\begin{itemize}
	\item Não é completo.
	\item Não é ótimo.
	\item Tem uma complexidade temporal $O(b^l)$.
	\item Tem uma complexidade espacial $O(bl)$.
\end{itemize}
\subsection{Procura por Aprofundamento Progressivo}
Opera como procura em profundidade até uma dada profundidade, após isso opera como procura em largura.\\
Se tiver insucesso aumenta a profundidade progressivamente.
Este algoritmo:
\begin{itemize}
	\item É completo.
	\item É ótimo se os custos forem constantes.
	\item Tem uma complexidade temporal $O(b^d)$.
	\item Tem uma complexidade espacial $O(bd)$.
\end{itemize}
\chapter{Procura Heurística}
A \textbf{pesquisa heurística} baseia-se na ideia de ter uma métrica que avalie quão promissores é que os estados são para alcançar o objetivo.
A essa métrica designa-se de \textbf{heurística}.
\section{Heurísticas}
Uma \textbf{função de avaliação} $f(n)$ determina quão promissor é que um nó é.\\
Uma \textbf{função heurística} $h(n)$ atribui um valor de proximidade ao objetivo a um nó.\\[2mm]
Uma heurística é:
\begin{itemize}
	\item \textbf{Admissível} se nunca sobrestimar o custo dos nós.\\
	Admissibilidade implica $h(n) \leq h^\star (n)$ (com $h^\star (n)$ a heurística com o custo real)
	\item \textbf{Consistente} se a função de avaliação é monótona com o aumento do caminho, nunca decrescente.\\
	Consistência implica que não existe um sucessor do nó $n$: $n'$ tal que o custo de alcançar o nó final por $n$ seja maior do que o custo de alcançar por $n'$ somado ao custo de alcançar $n'$ por $n$.
	\begin{center}
		\begin{tikzpicture}[scale=0.2]
		\tikzstyle{every node}+=[inner sep=0pt]
		\draw [black] (13.9,-22.7) circle (3);
		\draw (13.9,-22.7) node {$n$};
		\draw [black] (60.4,-22.7) circle (3);
		\draw (60.4,-22.7) node {final};
		\draw [black] (38.1,-30.2) circle (3);
		\draw (38.1,-30.2) node {$n'$};
		\draw [black] (16.9,-22.7) -- (57.4,-22.7);
		\fill [black] (57.4,-22.7) -- (56.6,-22.2) -- (56.6,-23.2);
		\draw (37.15,-23.2) node [below] {$h(n)$};
		\draw [black] (16.77,-23.59) -- (35.23,-29.31);
		\fill [black] (35.23,-29.31) -- (34.62,-28.6) -- (34.32,-29.55);
		\draw (20.97,-27.22) node [below] {$custo(n,n')$};
		\draw [black] (40.94,-29.24) -- (57.56,-23.66);
		\fill [black] (57.56,-23.66) -- (56.64,-23.44) -- (56.96,-24.39);
		\draw (51.79,-27.05) node [below] {$h(n')$};
		\end{tikzpicture}
	\end{center}
\end{itemize}
Diz-se que uma heurística \textbf{domina} outra se tem sempre um valor igual ou superior sendo melhor para procura.\\
Podem combinar-se heurísticas não dominantes com $\text{max}\{h_1(n), h_2(n)\}$
\subsection{Estimativa PathMax}
O PathMax é uma otimização aplicada durante a execução para manter uma heurística consistente.\\
Sendo $n$ um nó, $m$ um sucessor seu e $c(n,m)$ o custo para ir de $n$ até $m$ então a estimativa é dada por:
$$\hat h(m) = \text{max}\{(h(n) - c(n,m));h(m)\}$$
\clearpage
\section{Algoritmos Heurísticos}
\subsection{Procura Sôfrega}
A \textbf{procura sôfrega} é um algoritmo de procura heurística em que a função de avaliação é a função heurística.
$$f(n) = h(n)$$
O algoritmo avança sempre para o nó que aparenta estar mais próximo do objetivo.
\begin{itemize}
	\item Não é completa\\
	Pode ficar presa num ciclo de nós.\\
	No contexto de um mapa isso seria um caminho sem saída, ou uma superfície côncava.
	\item Não é ótima, pode rejeitar o caminho ótimo.\\
	No contexto de um mapa quando visto da origem, o caminho que vai na direção do destino pode não ser o caminho mais curto.
	\item Complexidade temporal $O(b^m)$, com uma má heurística.
	\item Complexidade espacial $O(b^m)$, mantém todos os nós em memória.
\end{itemize}
\subsection{Procura A*}
Na procura $A^\star$ (A-star) a função de avaliação é composta pela função heurística e pelo custo acumulado, considerando assim o esforço que já foi despendido e abandonando uma sequência se deixar de ser promissora.\\[2mm]
Com $g(n)$ o custo acumulado para atingir o nó $n$, a função de avaliação é:
$$f(n) = g(n) + h(h)$$
\begin{itemize}
	\item São expandidos todos os nós com função de avaliação inferior ao custo otimo.
	\item Não é expandido nenhum nó com função de avaliação superior ao custo ótimo.
	\item É completo, excetuando espaços com infinitos estados sub-ótimos.
	\item Complexidade temporal exponencial se $|h(n)| - h^\star (n) \leq O(log \> h^\star (n))$. Subexponêncial caso contrario.
	\item Mantêm todos os nós em memória.
\end{itemize}
Quando o algoritmo utiliza uma heurística não consistente, podem guardar-se associados aos nós explorados o menor custo já obtido e rejeitar caminhos piores, assim garante-se a ótimalidade da solução.
\clearpage
\section{Algoritmos Heurísticos em Espaço Limitado}
\subsection{Iterative Deepening A*}
O algoritmo \textbf{Iterative Deepening A*} (abreviado \textbf{IDA*}) é a execução do algoritmo A* com aprofundamento progressivo.
O valor de corte do aprofundamento progressivo é o menor valor da função de avaliação $f(n)$ durante a iteração anterior.
\begin{itemize}
	\item Mantem-se completo e ótimo.
	\item Tem uma complexidade espacial linear.
	\item É prático se os passos tiverem custos unitários.\\
	Em nós com custos reais pode as regenerações sucessivas podem implicar uma grande complexidade temporal.
\end{itemize}
\subsection{Recursive Best-First Search}
O algoritmo \textbf{Recursive Best-First Search} (abreviado \textbf{RBFS}) efetua uma procura em profundidade primeiro recursivamente enquanto o caminho for promissor.\\
Todos os nós expandidos tem associados uma variável \textit{limite} que indica o valor a partir do qual a atual sub-árvore deixa de ser vantajosa.
\begin{enumerate}
	\item Define na raiz da árvore um valor arbitrariamente grande.
	\item Geram-se os sucessores e calcula-se para cada o valor da função de avaliação.
	\item Enquanto o melhor valor for maior do que o \textit{limite} do pai, substitui-se o valor do pai por esse e sobe-se na árvore, apagando os sucessores no nível abandonado.
	\item Regista-se na variável \textit{limite} do melhor sucessor o valor da sua melhor alternativa.
	\item Se o melhor sucessor é nó final o algoritmo termina, senão expande-se o melhor sucessor e volta-se ao passo 2.
\end{enumerate}
\begin{itemize}
	\item Mantém-se completo e ótimo (no caso de uma heurística admissível).
	\item Complexidade temporal melhor que a do \textit{IDA*}.
	\item Baixo consumo de memória, mas pode regenerar sucessivamente os mesmos nós.
\end{itemize}
\subsection{Simplified Memory-Bounded A*}
O algoritmo \textbf{Simplified Memory-Bounded A*} (abreviado \textbf{SMA*}) aplica o A* até se atingir um limite de memória. Atingindo esse limite apaga da memória a folha com o pior valor. Esse nó só seria regenerado se todos os restantes caminhos se mostrarem piores, pelo que o seu valor é anexando ao pai para simplificação de cálculos.
\begin{itemize}
	\item Utilização ótima de memória.
	\item Completo e ótimo se existir uma solução que caiba em memória.
	\item Algoritmo ideal para procurar soluções ótimas, especialmente bom quando a geração de nós é mais dispendiosa do que a manutenção de memória.
\end{itemize}
\section{Outros Cenários}
Existem ainda algoritmos que são especialmente bons em certos cenários de procura:
\begin{itemize}
	\item Em tempo real com ações deterministas conhecidas de efeito desconhecido:
	\begin{itemize}
		\item Pesquisa cega: \textbf{Online-DFS} (requer ações reversiveis).
		\item Pesquisa informada: \textbf{LRTA*}.
	\end{itemize}
	\item Tolerância a alteração de custos em tempo real:
	\begin{itemize}
	\item \textbf{Dynamic A*} (\textbf{D*})
	\item \textbf{D* Lite}
	\end{itemize}
	\item Incrementais a partir de soluções subótimas:
	\begin{itemize}
	\item \textbf{Anytime repairing A*} (\textbf{ARA*})
	\item \textbf{Anytime dynamic A*} (\textbf{AD*})
	\end{itemize}
\end{itemize}
\chapter{Procura Local}
\section{Algoritmos iterativos de melhoramento}
Estes algoritmos partem de uma potencial solução ao problema em análise, e dispõem de uma medida de quão boa é a sua qualidade. Cada iteração tenta arranjar uma solução alternativa à atual que apresente mais qualidade.\\
Note-se que não é no entanto garantida a obtenção da solução ótima.\\[5mm]
O problema tem de ser formulado como um problema de otimização ou seja, tem de ser definido:
\begin{itemize}
\item O espaço de potenciais soluções, e o que pode ser uma solução (representada $x$).
\item A função $f(x)$ a ser otimizada.
\item O que se entende por ``pequenas alterações", ou seja, qual a vizinhança de um $x$, $V(x)$.
\end{itemize}
\subsection{Aplicação ao problema do caixeiro viajante}
\chapter{Agentes Lógicos}
\section{Bases de conhecimento}
Uma base de conhecimento (abreviado KB, do inglês \textit{knowledge base}) é um conjunto de \textbf{frases} numa linguagem \textbf{formal}.
As bases de conhecimento permitem construir agentes de forma \textbf{declarativa}, através de duas ações:\\
\begin{tabular}{r l}
$TELL \Leftarrow $ & A ação da base de conhecimento informar o sistema.\\
$ASK \Leftarrow $ & A ação do sistema questionar a sua base de conhecimento.
\end{tabular}\\[2mm]
Os agentes podem então ser analisados pelo:
\begin{itemize}
\item Nível de conhecimento\\
(Ex: A quantidade de conhecimento)
\item Nível de implementação\\
(Ex: As estruturas de dados na base de conhecimento e estruturas que manipulam)
\end{itemize}
Tendo os mesmos de ser capazes de:
\begin{itemize}
\item Representar novos estados, ações, ...
\item Incorporar novas perceções.
\item Atualizar representações internas do mundo.
\item Deduzir propriedades escondidas no mundo.
\item Deduzir ações apropriadas.
\end{itemize}
Exemplo da formulação de um agente simples:
\begin{algorithm}
\caption{Exemplo da utilização de uma base de conhecimento}
\begin{algorithmic}
\Function{KB-Agent}{percept}
\State    static KB, base de conhecimento
\State           $t$, um contador que indica tempo
\State    TELL(KB, MAKE-PERCEPT-SENTENCE(percept, $t$))
\State    action $\gets$ ASK(KB, MAKE-ACTION-QUERY($t$))
\State    TELL(KB, MAKE-ACTION-SENTENCE(action, $t$))
\State    $t \gets t + 1$
\State \Return action
\EndFunction
\end{algorithmic}
\end{algorithm}
\section{Lógica}
Linguagens \textbf{lógicas} são linguagens formais para representação de informação que permitem extração de conclusões.\\[2mm]
A \textbf{sintaxe} define as frases permitidas na linguagem.\\
\indent Ex: Em aritmética $x + 2 \geq y$ é uma frase (preposição), no entanto $x2 + y >$ não é.\\[2mm]
A \textbf{semântica} define o significado das frases.\\
\indent Ex: Em preposições aritméticas a semântica define a verdade da preposição.
\subsection{Conclusões}
A uma \textbf{conclusão} (ou consequência) lógica, designa-se ao que obteve o seu valor semântico indiretamente, por via de outros elementos linguísticos. Por exemplo o numero 7 ser primo é uma consequência da sua não divisibilidade por outros números que não 1.\\[2mm]
Havendo uma base de conhecimento KB, conclui-se dela uma frase $\alpha$, se $\alpha$ é verdade sempre que KB é verdade. (representando-se esta conclusão $\text{KB }\models \alpha$, isto é KB consequência de $\alpha$).\\[2mm]
Chama-se de \textbf{conclusão lógica} a uma relação entre frases que se baseia em \textbf{semântica}.
\subsection{Modelos}
Em lógica modelos são mundos formalmente estruturados dos quais se pode avaliar a veracidade de preposições.\\
Diz-se que $m$ é um modelo de uma preposição $\alpha$ se $\alpha$ é verdade em $m$.\\
Designa-se $M(\alpha)$ o conjunto de todos os modelos de $\alpha$.\\
Conclui-se portanto que se KB modela $\alpha$ ($\text{KB } \models \alpha$) então os modelos de KB são um subconjunto (ou iguais) aos modelos de $\alpha$ ($M(\text{KB}) \subseteq M(\alpha)$).\\
Ex: Sendo KB uma base de conhecimento que define as cadeiras que os alunos fizeram. Se $\alpha$ for a aprovação do João a Análise, então KB modela $\alpha$, é possível apurar $\alpha$ a partir de KB e $M(\text{KB}) \subseteq M(\alpha)$ verifica-se.
\subsection{Inferência}
Uma inferência lógica a método de obtenção de uma consequência lógica por base numa base de conhecimento. Representa-se de KB $\vdash_i \alpha$ obtenção da preposição $\alpha$ a partir de KB por base na inferência $i$.\\[2mm]
O procedimento de inferência $i$ é:
\begin{itemize}
\item \textbf{Fidedigno} (ou sólido): Se KB $\vdash_i \alpha$ implica que KB $\models \alpha$.\\
Isto é, inferir por base em implicações, sem assumir o que não se sabe ser verdade.
\item \textbf{Completo}: Se KB $\models \alpha$ implica que KB $\vdash_i \alpha$.\\
Isto é, capacidade de derivar as suas implicações.
\end{itemize}
Quando um procedimento de inferência é fidedigno e completo responde a qualquer questão conhecida pela base de conhecimento. Consegue-se retirar conclusões complexas de factos conhecidos, e decompor essas conclusões complexas para obter factos.
[Colocar esquema ilustrativo, frasear melhor]
\section{Lógica proposicional}
A lógica proposicional é a lógica mais simples. Ilustra conceitos básicos por base em símbolos (variáveis) proposicionais para constituição de proposições (frases).\\
Se $P_1, P_2$ forem proposições, o seguinte também o é:
\begin{itemize}
\item $\neg P_1$ (Negação)
\item $P_1 \wedge P_2$ (Conjunção)
\item $P_1 \vee P_2$ (Disjunção)
\item $P_1 \Rightarrow P_2$ (Implicação)
\item $P_1 \Leftrightarrow P_2$ (Bicondicional)
\end{itemize}
Os modelos atribuem valores booleanos aos símbolos proposicionais.\\
$n$ símbolos admitem no máximo $2^n$ modelos, consoante as preposições existentes.\\[5mm]
A avaliação da veracidade de um modelo $m$ é feita por disjunção das suas preposições, sendo cada preposição decomposta em sub-preposições até ser constituída apenas por símbolos e as operações descritas acima. O valor da expressão final dita a validade do modelo.\\[2mm]
Uma tabela de verdade permite enumerar todos os $2^n$ modelos teoricamente possíveis, verificar quais é que respeitam a base de conhecimento, e se uma dada preposição é sempre verdade.
\subsection{Equivalências}
Quando duas preposições são sempre iguais entre si, em todos os modelos, então são ditas \textbf{equivalentes}.\\
Equivalência entre dois modelos $\alpha, \beta$ representa-se $\alpha \equiv \beta$ e implica que $\alpha \models \beta \wedge \beta \models \alpha$.\\
As seguintes são equivalências da lógica proposicional:
\begin{itemize}
\item $(\alpha \wedge \beta) \equiv (\beta \wedge \alpha)$, comutatividade.
\item $(\alpha \vee \beta) \equiv (\beta \vee \alpha)$, comutatividade.
\item $((\alpha \wedge \beta) \wedge \gamma) \equiv (\alpha \wedge (\beta \wedge \gamma))$, associatividade.
\item $((\alpha \vee \beta) \vee \gamma) \equiv (\alpha \vee (\beta \vee \gamma))$, associatividade.
\item $\neg(\neg \alpha) \equiv \alpha$, eliminação da dupla negação.
\item $(\alpha \Rightarrow \beta) \equiv (\neg \beta \Rightarrow \neg \alpha)$, contraposição.
\item $(\alpha \Rightarrow \beta) \equiv (\neg \alpha \vee \beta)$, eliminação da implicação.
\item $(\alpha \Leftrightarrow \beta) \equiv ((\alpha \Rightarrow \beta) \wedge (\beta \Rightarrow \alpha))$, eliminação da bicondicional.
\item $\neg(\alpha \wedge \beta) \equiv (\neg \alpha \vee \neg \beta)$, De Morgan.
\item $\neg(\alpha \vee \beta) \equiv (\neg \alpha \wedge \neg \beta)$, De Morgan.
\item $(\alpha \wedge (\beta \vee \gamma)) \equiv ((\alpha \wedge \beta) \vee (\alpha \wedge \gamma))$, distributividade.
\item $(\alpha \vee (\beta \wedge \gamma)) \equiv ((\alpha \vee \beta) \wedge (\alpha \vee \gamma))$, distributividade.
\end{itemize}
\subsection{Validade e satisfatibilidade}
Uma proposição é \textbf{valida} se for verdadeira em todos os modelos.\\
A validade está relacionada com a consequência pelo \textbf{teorema da dedução}:
\begin{center}
KB $\models \alpha$ é valida apenas se KB $\Rightarrow \alpha$ é valida.
\end{center}
Uma proposição é \textbf{satisfazível} for verdade em pelo menos um modelo, e \textbf{insatisfazivel} caso contrario.\\
$A \wedge \neg A$ é um exemplo de uma preposição instatisfazivel.\\[2mm]
A insatisfabilidade pode ser relacionado com a consequência (pelo teorema acima) da seguinte forma:
\begin{center}
KB $\models \alpha$ é valida apenas se KB $\wedge \neg \alpha$ for insatisfazivel.
\end{center}
Um exemplo da utilização da utilidade deste caso do teorema é a prova por redução ao absurdo.
\subsection{Regras de inferência}
Existem padrões utilizados para efetuar inferência em lógica proposicional, são as \textbf{regras de inferência}.\\
Uma regra de inferência comum é designada \textbf{Modus Ponens} sendo escrita (no caso da implicação):
$$\frac{\alpha\to \beta, \quad \alpha}{\beta}$$
A leitura desta regra é ``\textit{se $\alpha$ implica $\beta$, e $alpha$ é verdade, então $\beta$ é verdade}".\\[2mm]
Uma \textbf{prova} é uma sequência de aplicações de regras de inferência que nos permite retirar uma conclusão.
\subsection{Monotonicidade}
A \textbf{monotonicidade} é uma propriedade que uma base de conhecimento pode verificar que formalmente é dada por:
$$(\text{KB}\models \alpha) \Rightarrow (\text{ KB}\wedge \beta \models \alpha)$$
Informalmente, indica que as conclusões não se perdem, que a base de conhecimento não ``muda de ideias" quanto ao seu raciocínio.
Um exemplo de uma base de conhecimento não-nonotónica é a mente humana.
\subsection{Formas conjuntivas}
Uma frase de lógica proposicional que seja dada por uma conjunção de disjunções está na \textbf{forma normal conjuntiva} (abreviada \textbf{FNC} ou \textbf{CNF}).\\
Todas as frases tem uma equivalente na forma normal conjuntiva. Para se obter essa forma os passos são (recorrendo ás equivalências):
\begin{enumerate}
\item Eliminar bicondicionais:\\
$(\alpha \Leftrightarrow \beta) \equiv ((\alpha \Rightarrow \beta) \wedge (\beta \Rightarrow \alpha))$
\item Eliminar implicações:\\
$(\alpha \Rightarrow \beta) \equiv (\neg \alpha \vee \beta)$
\item Eliminar negações que não em símbolos. Deixa-las ``penetrar" nas frases.\\
$\neg(\neg \alpha) \equiv \alpha$\\
$\neg(\alpha \wedge \beta) \equiv (\neg \alpha \vee \neg \beta)$\\
$\neg(\alpha \vee \beta) \equiv (\neg \alpha \wedge \neg \beta)$
\item Aplicar a distributividade.\\
$(\alpha \wedge (\beta \vee \gamma)) \equiv ((\alpha \wedge \beta) \vee (\alpha \wedge \gamma))$\\
$(\alpha \vee (\beta \wedge \gamma)) \equiv ((\alpha \vee \beta) \wedge (\alpha \vee \gamma))$
\end{enumerate}
\subsection{Clausulas de Horn}
Existe um formato especifico de frases na forma conjuntiva, as \textbf{clausulas de Horn} que consistem numa disjunção de símbolos em que no máximo uma é positiva. Por exemplo: $\neg a \vee \neg b \vee \dots \vee \neg y \vee z$\\
As clausulas de Horn verificam as seguintes propriedades:
\begin{itemize}
\item Todas podem ser escritas como implicações cuja premissa é a conjunção de símbolos positivos.
$$(a \wedge b \wedge \dots \wedge y) \Rightarrow z$$
\item Quando uma não tem símbolo negativo é uma preposição, um \textbf{facto}.
$$(\neg \text{Posição}_1 \vee \neg \text{Posição}_2) \equiv ((\text{Posição}_1 \wedge \text{Posição}_2) \Rightarrow \text{Falso})$$
\item Permitem inferência por base em \textbf{encadeamento para a frente} e \textbf{encadeamento para trás}.
\item Permitem verificar implicações é feito em tempo linear por base no tamanho da base de conhecimento.
\end{itemize}
\subsection{Encadeamento para a frente}
\subsection{Encadeamento para trás}
\pagebreak
\section{Exemplo: Mundo do Wumpus}
O mundo do Wumpus é um exemplo de um puzzle que pode ser resolvível com um agente.\\
É caraterizado por um mapa em grelha com diversas armadilhas, um inimigo, e um tesouro que se pretende obter.\\
O \textbf{ambiente} verifica que:
\begin{itemize}
\item Casas adjacentes ao Wumpus são mal-cheirosas.
\item Casas adjacentes a um poço são ventosas.
\item Brilho só se ouro está na mesma casa.
\item Disparo mata Wumpus se estiver em frente.
\item Disparar gasta única seta.
\item Agarrar apanha o ouro da casa.
\item Largar deixa o ouro na mesma casa.
\end{itemize}
O agente tem os seguintes \textbf{sensores}:
\begin{itemize}
\item Brisa, brilho, cheiro, grito e batida.
\end{itemize}
E os seguintes \textbf{atuadores}:
\begin{itemize}
\item Rodar esquerda, rodar direita, avançar, agarrar, largar, disparar, sair.
\end{itemize}
Uma medida de desempenho poderá seguir os critérios:
\begin{itemize}
\item Sair com ouro: +1000 pontos
\item Morte: -1000 pontos
\item Passo: -1 pontos
\item Utilizar a seta: -10 pontos
\end{itemize}
Assim uma caraterização do mundo conclui que é:
\begin{itemize}
\item \textbf{Não observável} - Só se perceciona o próprio local.
\item \textbf{Determinístico} - Os resultados das mesmas ações são sempre idênticos.
\item \textbf{Não episódico} - Ações sequenciais.
\item \textbf{Estático} - O Wumpus e os poços não se movem.
\item \textbf{Discreto} - As ações são atómicas.
\item \textbf{Agente único} - Mais nada interage com o ambiente.
\end{itemize}
[Ilustrar mapa, Tikz?]\\[5mm]
Dão-se situações em que não existe nenhum caminho livre de risco, como o jogador se encontrar na posição (1,1) e existir um poço na posição (2,2). Qualquer movimento admite uma chance de erro.\\
Para os cenários desconhecidos estudam-se os modelos possíveis.
No mundo do Wumpus a base de conhecimento é uma agregação das regras de jogo ás observações já efetuadas.
\section{Lógica de primeira ordem}
A lógica proposicional é \textbf{declarativa} e uma linguagem de programação é \textbf{procedimental}. Enquanto que a linguagem de programação é mais expressiva, não lida bem com informação parcial (como duas posições possíveis em simultâneo) requerendo abstrações.\\[2mm]
A \textbf{lógica de primeira ordem}(abreviada \textbf{LPO}) é uma linguagem muito mais expressiva (e dispendiosa computacionalmente) do que a lógica proposicional, mantendo-se declarativa. Tem os seguintes elementos:
\begin{itemize}
\item \textbf{Objetos} - Entidades existentes no mundo.\\
Batatas, segundos, números, ...
\item \textbf{Relações} - Propriedades dos objetos que podem ser $n$-árias.\\
Amigos(João, Ana), Azul(Céu)
\item \textbf{Funções} - Um tipo particular de relação que é unária e representa um objeto.\\
Nota(João)
\end{itemize}

Existem diversas lógicas baseadas nesta, para diversas especialidades, como a \textbf{lógica temporal}, que assume que as definições só são validas em pontos ou intervalos temporais ou as \textbf{lógicas de ordens elevadas} que tratam as relações como objetos que por sua vez podem ter relações.

As lógicas são caraterizadas também pelos seus \textbf{compromissos epistémicos}, os estados de conhecimento admitidos em cada facto. Á semelhança da lógica proposicional, a lógica de primeira ordem admite valores booleanos. Lógicas como a \textbf{lógica difusa} permitem responder a questões como ``\textit{Lisboa é uma grande cidade}" com um grau de confiança.
\subsection{Sintaxe}
\begin{itemize}
\item Os objetos são o domínio da linguagem, o qual não pode ser vazio.
\item Uma relação é definida com um conjunto de tuplos. Por exemplo a relação amigos:
$$\{<\text{João}, \text{Ana}>, <\text{Inês}, \text{António}>\}$$
\item Os modelos em lógica de primeira ordem requerem funções totais, em que todos os objetos tem de estar relacionados, sendo que quando uma relação não existe ou não faz sentido existir pode ser definida entre o objeto e um outro objeto criado especificamente para representar ausência de relação.
\item Tudo é um símbolo. Os objetos, as relações e as funções são \textbf{símbolos constantes}, \textbf{símbolos predicativos} e \textbf{símbolos funcionais}, respetivamente.
\item Cada símbolo predicativo tem uma \textbf{aridade} que determina o numero de argumentos.
\item Cada objeto pode ser dado por diversos símbolos, sendo a \textbf{interpretação} que dita o mapeamento.
\item Uma frase atómica (átomo) é dada por uma lista de termos em parêntesis. Por exemplo $Amigos(\text{João}, \text{Ana})$.
\item Podem ser utilizados conectivos lógicos, como visto na lógica proposicional.
\item Os símbolos predicativos podem ser utilizados sobre outros símbolos.
\item Podem ser declaradas variáveis que podem assumir símbolos constantes.
\item Existem \textbf{quantificadores}. O \textbf{universal} ($\forall$) e o \textbf{existencial} ($\exists$).
\item O operador de igualdade ($=$) define que dois símbolos se referem ao mesmo objeto.
\end{itemize}
\chapter{Incerteza}
Quando se lida com informação parcial(ambientes parcialmente observáveis ou não determinísticos) um agente tem de tratar todas as hipóteses que não são refutadas pela lógica como sendo possíveis, e ainda de saber lidar com a possibilidade de não chegar ao seu estado objetivo. Por exemplo um veiculo autónomo tem a possibilidade de avariar ou ter um acidente, independentemente de quanto tempo tenha para chegar.\\[2mm]
Perante incerteza todos os casos possíveis podem ser enumerados, de tal forma que todos os estados do mundo estejam implicados como uma enorme disjunção de causas possíveis, mas tal não é viável, tanto por desconhecimento do mundo, do estado ou por haverem demasiadas causas.

Quando um agente tem de decidir perante incerteza recorre à \textbf{utilidade} das suas ações de acordo com as respetivas \textbf{probabilidades} de sucesso. Idealmente opta pela sequência de ações que causem a maior utilidade esperada.\\[2mm]
Afirmações probabilísticas em mundos incertos não incidem sobre mundos possíveis, mas sim sobre \textbf{eventos}, com um evento sendo um \underline{conjunto} de mundos possíveis. Estes conjuntos são descritos com preposições que verificam.
\section{Probabilidades}
As probabilidades são dependentes de interpretação, e existem diversas formas de pensar nelas:
\begin{itemize}
\item Frequentista: Rácio de experiências que verifica uma condição mediante infinitas experiências.
\item Objetivista: Aspetos do universo. (controversa)
\item Bayesiana: Crenças que o agente pode ter perante circunstâncias desconhecidas.
\end{itemize}
As probabilidades em torno de uma variável aleatória, como $P(X=x)$, são probabilidades \textbf{incondicionais}.
Quando já se sabem detalhes de uma variável aleatória podem querer sabendo as probabilidades de um evento por base nas caraterísticas da variável, sendo estas probabilidades \textbf{condicionais}. Por exemplo, com dois dados, $P(\text{duplo}|D_1 = 4)$.\\[5mm]
Relembrar que a \textbf{probabilidade condicionada} é dada por: $P(a|b) = \frac{P(a \wedge b)}{P(b)}$\\
E que a partir dela pode ser vista a \textbf{regra do produto}: $P(a \wedge b) = P(a|b)P(b)$\\[2mm]
Com a regra do produto pode intuitivamente calcular-se a \textbf{probabilidade conjunta}, que consiste na probabilidade de se acabar nos mundos em que várias variáveis aleatórias correspondem a valores desejados:
$$P(\text{Vegetariano, Saúdavel}) = P(\text{Vegetariano}|\text{Saúdavel})P(\text{Saúdavel})$$
Perante duas variáveis aleatórias pode ser-se feita a \textbf{tabela de probabilidade conjunta}, que estuda as combinações dos valores possíveis de ambas para variáveis aleatórias discretas (e possivelmente de intervalos para continuas).\\[2mm]
A soma de todas as probabilidades condicionadas ou conjuntas que envolvem uma variável aleatória corresponde á probabilidade de ocorrência dessa variável enquanto incondicional. Essas duas operações são formuladas:
$$P(Y) = \sum_{z \in Z}{P(Y, z)} \qquad P(Y) = \sum_{z \in Z}{P(Y| z)P(z)}$$
Designam-se \textbf{marginalização} e \textbf{condicionamento}, respetivamente. Da marginalização obtem-se a \textbf{probabilidade marginal}.\\
Por exemplo a probabilidade de sair de casa sabendo que chove somada á probabilidade de sair de casa sabendo que não chove é a probabilidade de sair de casa.\\[5mm]
Quando duas variáveis aleatórias não tem influência uma na outra dizem-se \textbf{independentes}.\\
Variáveis aleatórias independentes ($X$ e $Y$ neste caso) verificam:
$$P(X|Y)=P(X) \qquad P(Y|X)=P(Y) \qquad P(X,Y) = P(X)P(Y)$$\\[5mm]
A partir da regra do produto é possível obter a \textbf{regra de Bayes}, um dos fundamentos da inferência em IA:
$$P(X|Y)=\frac{P(Y|X)P(X)}{P(Y)} \qquad \text{sendo intrepretada:} \qquad 
P(\textit{efeito}|\textit{causa})=\frac{P(\textit{causa}|\textit{efeito})P(\textit{efeito})}{P(\textit{causa})}$$
Para simplificar contas ou por desconhecimento pode aplicar-se \textbf{normalização}, que corresponde á substituição do denominador do segundo termo por uma constante.
$$P(X|Y) = \alpha P(Y|X)P(X)$$
A regra de Bayes pode ser utilizada de uma forma \textbf{causal} quando se pretendem saber os efeitos a partir de causas ($P(\textit{efeito}|\textit{causa})$) ou de uma forma \textbf{diagnostica} quando se querem saber causas a partir de efeitos ($P(\textit{causa}|\textit{efeito})$).\\[2mm]
No entanto a forma diagnóstica é muito mais frágil do que a causal. Se a probabilidade de uma causa se altera (como uma epidemia de uma doença) as probabilidades $P(\textit{causa}|\textit{efeito})$ dessa causa mudam, no entanto as diversas $P(\textit{efeito}|\textit{causa})$ mantém-se inalteradas..\\[5mm]
A Regra de Bayes pode ser utilizada com tantos factos quão seja necessário. Com $n$ causas:
$$P(\textit{causa}|\textit{efeito}_1,\textit{efeito}_2, \dots, \textit{efeito}_n) =
\alpha P(\textit{efeito}_1,\textit{efeito}_2, \dots, \textit{efeito}_n| \textit{causa}) P(\textit{causa})$$
No entanto sendo necessário conhecer a probabilidade conjunta entre todos os casos possíveis, muito rapidamente se torna impossível lidar o numero exponencial de combinações de variáveis aleatórias.\\[2mm]
A \textbf{independência condicional} entre variáveis simplifica muito a aplicação da regra de Bayes.\\
Com todos os $X_i,X_j \in X$ independentes entre si:
$$P(X_1,X_2,\dots|Z)=\prod_i P(X_i | Z) \qquad \text{e} \qquad P(Z | X_1,X_2,\dots)= P(Z)\prod_i P(X_i | Z) \qquad \text{ portanto:}$$
$$P(\textit{efeito}_1 \wedge \dots \wedge \textit{efeito}_n|\textit{causa}) =
P(\textit{efeito}_1|\textit{causa})P(\dots|\textit{causa})P(\textit{efeito}_n|\textit{causa})$$
$$\qquad\qquad P(\textit{causa}|\textit{efeito}_1 \wedge \dots \wedge \textit{efeito}_n) =
\alpha P(\textit{efeito}_1|\textit{causa})P(\dots|\textit{causa})P(\textit{efeito}_n|\textit{causa})P(\textit{causa})$$
A ``\textit{causa}" não pode ser simplificada não ser independente dos seus efeitos. A este modelo chama-se de \textbf{naive Bayes}.
\section{Redes Bayesianas}
\end{document}
